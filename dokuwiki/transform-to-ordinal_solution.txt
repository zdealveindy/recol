====== Transform the percentage cover values into ordinal scale - Solution ======

The first option is to use a sequence of ''ifelse (CONDITION, EXPR1, EXPR2)'' functions, which can take as an argument vector or matrix:
<code rsplus>
transform2brbl_1 <- function (data)
  {
  ifelse (data == 0, 0, 
    ifelse (data <= 1, 1, 
      ifelse (data <= 2, 2, 
        ifelse (data <= 3, 3, 
          ifelse (data <= 25, 4, 
            ifelse (data <= 50, 5, 
              ifelse (data <= 75, 6, 7)))))))
  }
</code>

An alternative option is to use the loop and evaluate each element separately using nested sequence of ''if (CONDITION) EXPR1 else EXPR2'':
<code rsplus>
transform2brbl_2 <- function (data)
{
  t.data <- as.matrix(data)
  for (ro in seq (1, nrow (t.data)))
    for (co in seq (1, ncol (t.data)))
    {
      t.data[ro,co] <- if (t.data[ro,co] == 0) 0 else
        if (t.data[ro,co] <= 1) 1 else
          if (t.data[ro,co] <= 2) 2 else
            if (t.data[ro,co] <= 3) 3 else
              if (t.data[ro,co] <= 25) 4 else
                if (t.data[ro,co] <= 50) 5 else
                  if (t.data[ro,co] <= 75) 6 else 7
    }
  dim (t.data) <- dim (data)
  dimnames (t.data) <- dimnames (data)
  return (t.data)
}
</code>
Note that I had to solve the problem that the function needs to cope with both vector and data.frame (''1:100'' is a vector, while ''vltava.spe'' is a data.frame). At the same time, since ''if'' ''else'' statement can evaluate only a single CONDITION, it has to loop through the two-dimensional data frame element by element (row by row and column by column, see the double ''for'' loop). Eventually, I need to make sure that if the original ''data'' were a vector, the output will also become vector; this is achieved by assigning the ''t.data'' the same ''dim'' (dimension) as was the original ''data''. If this was a vector, the ''dim'' function returns ''NULL'', and assigning this to the matrix will turn it into the vector; if it was originally matrix or data.frame, the number of rows and columns will remain. I also need to make sure to assign dimnames in some way, here using the function ''dimnames''.

In a slightly different solution, I can use the previous solution and every time make sure that the value really fits the specific range (e.g. it is larger than 3 but smaller or equal to 25). This is not really necessary, since the previous solution is already exclusive enough, but it is possible to do:
<code rsplus>
transform2brbl_3 <- function (data)
{
  t.data <- as.matrix (data)
  for (ro in seq (1, nrow (t.data)))
    for (co in seq (1, ncol (t.data)))
    {
      t.data[ro,co] <- if (t.data[ro,co] == 0) 0 else
        if (t.data[ro,co] > 0 & t.data[ro,co] <= 1) 1 else
          if (t.data[ro,co] > 1 & t.data[ro,co] <= 2) 2 else
            if (t.data[ro,co] > 2 & t.data[ro,co] <= 3) 3 else
              if (t.data[ro,co] > 3 & t.data[ro,co] <= 25) 4 else
                if (t.data[ro,co] > 25 & t.data[ro,co] <= 50) 5 else
                  if (t.data[ro,co] > 50 & t.data[ro,co] <= 75) 6 else 7
    }
  dim (t.data) <- dim (data)
  dimnames (t.data) <- dimnames (data)
  return (t.data)
}
</code>

In a final variation on ''for'' loop and ''if else'' sequence is to replace ''if (condition) do.something else do.something.else'' structure by only ''if (condition) do.something''. This makes the script more complicated, and also I now have to use the double comparison (e.g. ''x > 3 & x <= 25''), because each line of script with ''if'' statement is evaluated independently from the others (it's not nested using ''if'' ''else''): 
<code rsplus>
transform2brbl_4 <- function (data)
{
  t.data <- as.matrix (data)
  for (ro in seq (1, nrow (t.data)))
    for (co in seq (1, ncol (t.data)))
    {
      if (t.data[ro,co] == 0) t.data[ro,co] <- 0
      if (t.data[ro,co] > 0 & t.data[ro,co] <= 1) t.data[ro,co] <- 1
      if (t.data[ro,co] > 1 & t.data[ro,co] <= 2) t.data[ro,co] <- 2
      if (t.data[ro,co] > 2 & t.data[ro,co] <= 3) t.data[ro,co] <- 3
      if (t.data[ro,co] > 3 & t.data[ro,co] <= 25) t.data[ro,co] <- 4
      if (t.data[ro,co] > 25 & t.data[ro,co] <= 50) t.data[ro,co] <- 5
      if (t.data[ro,co] > 50 & t.data[ro,co] <= 75) t.data[ro,co] <- 6
      if (t.data[ro,co] > 75 & t.data[ro,co] <= 100) t.data[ro,co] <- 7
    }
  dim (t.data) <- dim (data)
  dimnames (t.data) <- dimnames (data)
  return (t.data)
}

</code>

A completely different solution, introduced by Lu Chung-Hsuan, which is not using ''ifelse'', or ''for'' loop with ''if else'' conditional functions, is to use function ''replace''. Consider checking ''?replace'' if you are not familiar with how the function works. The function ''replace'' has three arguments: ''x'', by which it takes an object (vector, matrix, or data.frame), ''list'', which needs to be an index vector or logical vector, and finally ''values'', which contains replacement values.

<code rsplus>
transform2brbl_5 <- function (data) 
  {
  data1 <- (data > 0 & data <= 1)   
  data1. <- replace (data1, data1 > 0, 1) 
  
  data2 <- (data > 1 & data <= 2)   
  data2. <- replace (data2, data2 > 0, 2)
  
  data3 <- (data > 2 & data <= 3)   
  data3. <- replace (data3, data3 > 0, 3)
  
  data4 <- (data > 3 & data <= 25)   
  data4. <- replace (data4, data4 > 0, 4)
  
  data5 <- (data > 25 & data <= 50)   
  data5. <- replace (data5, data5 > 0, 5)
  
  data6 <- (data > 50 & data <= 75)   
  data6. <- replace (data6, data6 > 0, 6)
  
  data7 <- (data > 75 & data <= 100)   #Save the wanted data points into the same type of framework as input data in form of Boolean value
  data7. <- replace (data7, data7 > 0, 7) #Then replace the 'TRUE' into suitable value depending on the ordinal-percentage relationship 
  
  datatotal <- (data1. + data2. + data3. + data4. + data5. + data6. + data7.) #Simply summing up to merge every replaced data
  return (datatotal)
  }
</code>


Let's check whether the functions work. You can find all four functions [[https://raw.githubusercontent.com/zdealveindy/recol/main/rcodes/transform2brbl.r|here]] and source them at once using this code:

<code rsplus>source ("https://raw.githubusercontent.com/zdealveindy/recol/main/rcodes/transform2brbl.r")
 
</code>

<code rsplus>
vltava.spe <- read.delim ('https://raw.githubusercontent.com/zdealveindy/recol/main/data/vltava-spe.txt', row.names = 1)
transform2brbl_1 (vltava.spe)[1:10, 1:10]
 
</code>
<file>
   Abiealb23 Acerpla23 Acerpse23 Alnuglu23 Alnuinc23 Berbvul23 Betupen23 Carpbet23 Coryave23 Cratspe23
1          0         0         0         0         0         0         0         0         4         0
2          0         0         0         0         0         0         0         0         2         0
3          0         0         0         0         0         0         0         0         5         0
4          0         0         0         0         0         0         0         0         4         0
5          0         0         0         5         0         0         0         0         0         0
6          0         5         0         0         0         0         0         0         4         0
7          0         0         2         0         0         0         0         5         4         0
8          0         0         2         0         0         0         0         0         4         0
9          0         2         0         0         0         0         3         0         3         0
10         0         0         0         0         0         0         2         0         3         0
</file>

We can also check whether all functions return the same result. There is the function ''identical'', which compares whether its arguments are identical (values, format, attributes):
<code rsplus>
identical (transform2brbl_1 (vltava.spe), transform2brbl_2 (vltava.spe), transform2brbl_3 (vltava.spe), transform2brbl_4 (vltava.spe), transform2brbl_5 (vltava.spe))
</code>
<file>
[1] TRUE
</file>

To visually confirm that the transformation works, we may project against each other the original percentage values with the transformed ordinal values for all observations((Note that the matrix-like objects in the arguments of ''plot'' function need to be really matrices, not data frames.)):
<code rsplus>
plot (as.matrix (vltava.spe), as.matrix (transform2brbl_1 (vltava.spe)), 
      xlab = 'Percentage cover values', ylab = 'Ordinal cover values')
</code>
{{:recol:figures:percentage-ordinal-vltava.png?direct|}}

Finally, we may also compare the speed of all four functions. Such comparison is called benchmarking and is important in the case that you want to choose a function/code which runs faster and is more efficient. This is not a big deal for a small dataset, but may become crucial for large datasets, especially if the operation is being repeated many times.
To benchmark out two functions ''transform2brbl_1'' and ''transform2brbl_2'', we can use ''library (microbenchmark)'' (you  need to install the library first, since it's not build-in part of standard R-program distribution - use ''install.packages ("microbenchmark")'' for this purpose).

<code rsplus>
library (microbenchmark)
bench <- microbenchmark (transform2brbl_1(vltava.spe),
                         transform2brbl_2(vltava.spe),
                         transform2brbl_3(vltava.spe),
                         transform2brbl_4(vltava.spe),
                         transform2brbl_5(vltava.spe))

bench
</code>
<file>
Unit: milliseconds
                         expr      min        lq      mean    median        uq      max neval
 transform2brbl_1(vltava.spe)   9.9690  10.48960  12.02440  11.01145  12.97955  44.5351   100
 transform2brbl_2(vltava.spe)  16.2161  16.50325  17.72269  16.82170  17.27980  48.8564   100
 transform2brbl_3(vltava.spe)  19.5038  19.90840  21.46993  20.33060  21.73750  55.4642   100
 transform2brbl_4(vltava.spe) 191.3079 192.79565 197.17035 193.95505 195.97545 228.0766   100
 transform2brbl_5(vltava.spe)  19.0699  19.88180  21.31514  21.53365  21.96205  35.9646   100
</file>

Or use the object ''bench'' calculated by ''microbenchmark'' to draw the boxplot of comparison:
<code rsplus>
boxplot (bench, names = paste ('transform2brbl', 1:5, sep = '_'))
</code>
{{:recol:figures:boxplot-microbenchmark-transform2brbl.png?direct|}}


Function ''microbenchmark'' will take each function in the argument separately and repeat it 100 times (default value setup by the argument ''times = 100'' within the function ''microbenchmark'' - you may decrease it if it takes too much time on your computer).

As we can see from the column ''mean'' and ''median'' in the table above, functions differ - the first one is the fastest, the second slightly slower, the third even slower and the fourth almost 10 times slower than the first. Note, however, that absolute times differ on different computers (depending on the speed of your processor((My computer parameters are as follows: <code>Operating System: Windows 10 Pro 64-bit;
Processor: 11th Gen Intel(R) Core(TM) i7-11700 @ 2.50GHz   2.50 GHz</code>)) and how busy the computer is at the time when you do the benchmarking). So, while the most optimized function takes on average only 0.03 seconds to transform ''vltava.spe'' into the Braun-Blanquet scale, the last one takes more than a quarter of a second (0.25) to do the same job. For larger datasets, this time difference may be an issue.
